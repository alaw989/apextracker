---
phase: 04-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/cache.js
  - src/composables/useApiCache.js
  - src/stores/player.js
  - src/components/ui/TimestampBadge.vue
  - src/components/ui/RefreshButton.vue
  - src/views/PlayerView.vue
autonomous: true

must_haves:
  truths:
    - "Repeated searches for same player show cached data immediately"
    - "Cache timestamp displays showing when data was last updated"
    - "Manual refresh button allows forcing fresh data fetch"
    - "Data older than 15 minutes triggers background revalidation"
    - "Cache persists across browser sessions via localStorage"
  artifacts:
    - path: "src/utils/cache.js"
      provides: "LRU cache wrapper with localStorage persistence"
      exports: ["getCache", "setCache", "updateLRU"]
    - path: "src/composables/useApiCache.js"
      provides: "Stale-while-revalidate logic"
      exports: ["useApiCache"]
    - path: "src/components/ui/TimestampBadge.vue"
      provides: "Time-ago display component"
      min_lines: 30
    - path: "src/components/ui/RefreshButton.vue"
      provides: "Manual refresh trigger button"
      min_lines: 40
  key_links:
    - from: "src/stores/player.js"
      to: "src/composables/useApiCache.js"
      via: "import and useApiCache composable"
      pattern: "useApiCache"
    - from: "src/composables/useApiCache.js"
      to: "src/utils/cache.js"
      via: "localStorage wrapper functions"
      pattern: "(getCache|setCache)\\("
    - from: "src/views/PlayerView.vue"
      to: "src/components/ui/TimestampBadge.vue"
      via: "component import and usage"
      pattern: "TimestampBadge"
    - from: "src/views/PlayerView.vue"
      to: "src/components/ui/RefreshButton.vue"
      via: "component import and @refresh handler"
      pattern: "RefreshButton.*@refresh"
---

<objective>
Implement API response caching using stale-while-revalidate pattern to eliminate redundant API calls and respect rate limits.

Purpose: Repeated searches for the same player should return cached data immediately while silently fetching fresh data in the background. This reduces API load, improves perceived performance, and prevents rate limit issues.

Output: A caching layer with localStorage persistence, LRU eviction, time-based staleness (15 min freshness window), cache timestamp display, and manual refresh button.
</objective>

<execution_context>
@/home/deck/.claude/get-shit-done/workflows/execute-plan.md
@/home/deck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance/04-CONTEXT.md
@.planning/phases/04-performance/04-RESEARCH.md

# Locked Decisions from CONTEXT.md
- Stale-while-revalidate pattern — Show cached data immediately, fetch fresh in background
- 15 minute freshness window — Data considered fresh for 15 minutes, then stale
- Show cache timestamp — Display "Updated X min ago" so users know data age
- Manual refresh button — Small icon, always available, lets users force fresh data
- localStorage — Cache survives browser close, available on return visits
- No manual cache clearing — Cache manages itself automatically
- No user-facing cache controls — Users don't need to think about it

@src/stores/player.js
@src/utils/api.js
@src/views/PlayerView.vue
@src/composables/usePageTitle.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create localStorage cache utility with LRU eviction</name>
  <files>src/utils/cache.js</files>
  <action>
Create a new file `src/utils/cache.js` with the following:

1. **Constants:**
   - `MAX_CACHE_SIZE = 10` — Maximum number of player lookups to store
   - `LRU_KEY = 'cache:lru'` — localStorage key for LRU tracking
   - `CACHE_PREFIX = 'cache:player:'` — Prefix for player cache entries

2. **Function `updateLRU(key)`:**
   - Parse existing LRU array from localStorage or initialize empty
   - Remove key if already exists (to move to end)
   - Push key to end of array (most recently used)
   - If array exceeds MAX_CACHE_SIZE, shift oldest key and remove from localStorage
   - Save updated LRU array to localStorage

3. **Function `getCache(key)`:**
   - Call updateLRU(key) to mark as recently used
   - Get item from localStorage using `CACHE_PREFIX + key`
   - Parse JSON and return, or null if not found

4. **Function `setCache(key, value)`:**
   - Call updateLRU(key) to mark as recently used
   - Stringify value and store in localStorage using `CACHE_PREFIX + key`
   - Wrap in try/catch for QuotaExceededError
   - On error: If quota exceeded, clear oldest entry via LRU and retry
   - If still fails: Return error (caller falls back to no cache)

5. **Function `clearCache()`:** (for testing/debugging)
   - Get LRU array from localStorage
   - Remove each cache entry
   - Remove LRU key itself

Per Claude's discretion on localStorage full handling: Use LRU eviction on QuotaExceededError with single retry. If still fails, throw error gracefully (cache becomes in-memory for that session).
  </action>
  <verify>
Run `npm run dev` and in browser console test:
```javascript
import { getCache, setCache } from '/src/utils/cache.js'
setCache('test', { data: 'hello', time: Date.now() })
getCache('test') // Should return { data: 'hello', time: ... }
```
  </verify>
  <done>
Cache utility exists with getCache, setCache, updateLRU, clearCache exports. LRU eviction works (exceeding MAX_CACHE_SIZE removes oldest entry). QuotaExceededError handled gracefully.
</done>
</task>

<task type="auto">
  <name>Task 2: Create useApiCache composable with stale-while-revalidate</name>
  <files>src/composables/useApiCache.js</files>
  <action>
Create a new file `src/composables/useApiCache.js` with the following:

1. **Imports:**
   - `ref`, `computed` from 'vue'
   - `getCache`, `setCache` from '@/utils/cache.js'

2. **Constants:**
   - `CACHE_TTL = 15 * 60 * 1000` — 15 minutes freshness window

3. **Function `useApiCache(cacheKey)`:**
   - **State:**
     - `cached` ref(null) — Cached data
     - `timestamp` ref(null) — When data was cached
     - `isLoading` ref(false) — Fetch in progress flag
     - `isStale` computed — Returns true if timestamp older than CACHE_TTL
     - `age` computed — Returns human-readable time ago string

   - **`loadFromCache()` internal:**
     - Call getCache with cacheKey
     - If exists, set cached and timestamp from returned object

   - **`fetchWithCache(fetchFn)` async:**
     - First, load from cache (sets cached/timestamp if exists)
     - If cached data exists AND is fresh (within TTL), return cached immediately
     - If cached is stale OR doesn't exist:
       - Set isLoading = true
       - Call fetchFn() to get fresh data
       - Update cached, timestamp with fresh data
       - Persist via setCache(cacheKey, { data: fresh, time: Date.now() })
       - Set isLoading = false
       - Return fresh data
     - For stale-while-revalidate: Return cached immediately if exists, then fetch fresh in background

   - **Return object:** { cached, timestamp, isLoading, isStale, age, fetchWithCache }

4. **Helper `timeAgo(timestamp)` function:**
   - Convert timestamp to "X min ago" format
   - "Just now" for < 60 seconds
   - "X min ago" for < 60 minutes
   - "X hr ago" for < 24 hours
   - "X days ago" for older
   - Export this function separately for use in components

Use existing fetchPlayerStats from api.js as the fetchFn signature.
  </action>
  <verify>
Create test in browser console:
```javascript
import { useApiCache } from '/src/composables/useApiCache.js'
const { fetchWithCache, cached, isStale } = useApiCache('test-key')
await fetchWithCache(async () => ({ test: 'data' }))
// First call should cache, second should return cached immediately
```
  </verify>
  <done>
Composable exports useApiCache and timeAgo. Stale-while-revalidate pattern works (cached returns immediately, fresh fetches in background when stale). 15-minute TTL enforced.
</done>
</task>

<task type="auto">
  <name>Task 3: Integrate caching into player store and create UI components</name>
  <files>src/stores/player.js src/components/ui/TimestampBadge.vue src/components/ui/RefreshButton.vue src/views/PlayerView.vue</files>
  <action>
**Part A: Modify src/stores/player.js**

1. Add imports:
   - Import `useApiCache` from '@/composables/useApiCache.js'

2. Inside `defineStore`, create cache instance:
   - `const apiCache = useApiCache(null)` — Cache key set dynamically per lookup

3. Modify `searchPlayer` function:
   - Generate cache key: `const cacheKey = \`\${platform}:\${username}\``
   - Update cache instance key (may need to recreate cache with new key or pass key to fetchWithCache)
   - Call `fetchWithCache(() => fetchPlayerStats(username, platform))`
   - If cached data returned immediately, display it
   - Set `data.value` from cached or fresh response
   - Store timestamp in new `cacheTimestamp` ref for UI display
   - Return object with `fromCache: boolean` flag

4. Add new state:
   - `cacheTimestamp` ref(null) — When current data was cached
   - `isRefreshing` computed — Returns true when background fetch in progress
   - `age` computed — Returns formatted time ago string

5. Add `forceRefresh` action:
   - Bypasses cache, forces fresh API call
   - Updates cache with new data

**Part B: Create src/components/ui/TimestampBadge.vue**

1. Props: `timestamp` (Number, optional)
2. Display small gray badge with "Updated X min ago" text
3. Use `timeAgo` utility for formatting
4. Style: Compact, muted colors, positioned near player name
5. Show nothing if timestamp is null

**Part C: Create src/components/ui/RefreshButton.vue**

1. Props: `loading` (Boolean), `disabled` (Boolean)
2. Emits: `refresh` event on click
3. Small circular button with refresh icon (SVG)
4. Spins while loading
5. Accessibility: aria-label="Refresh data", disabled state handled
6. Style: Subtle, not prominent (small icon button)

**Part D: Modify src/views/PlayerView.vue**

1. Import TimestampBadge and RefreshButton
2. Place TimestampBadge near player name in PlayerHeader area
3. Place RefreshButton in corner of stats area
4. Wire RefreshButton @refresh to store.forceRefresh action
5. Pass loading state to RefreshButton via store.isRefreshing
  </action>
  <verify>
1. Search for a player twice — second search should be instant (from cache)
2. Check browser localStorage — should see `cache:lru` and `cache:player:...` entries
3. Click refresh button — should fetch fresh data
4. Wait 15+ minutes then search cached player — should show cached data immediately, then update silently
5. Check timestamp badge displays correct time ago
  </verify>
  <done>
Player store integrates with useApiCache. Repeated searches show cached data immediately. TimestampBadge shows "Updated X min ago". RefreshButton forces fresh fetch. Cache persists across page reloads. LRU eviction works (11th lookup evicts oldest).
</done>
</task>

</tasks>

<verification>
1. **Cache persistence check:** Search for player, reload page, search same player — should be instant (from localStorage)
2. **Stale-while-revalidate:** Search for player >15min old — should show cached data, then silently update
3. **Manual refresh:** Click refresh button — forces fresh API call regardless of cache age
4. **LRU eviction:** Search for 11 different players — oldest should be evicted (verify in localStorage)
5. **Rate limit protection:** Repeatedly search same player — only one actual API call per 15 minutes
6. **Timestamp accuracy:** TimestampBadge shows correct time ago format (minutes, hours, days)
7. **QuotaExceededError handling:** Simulate full localStorage — cache degrades gracefully to in-memory
</verification>

<success_criteria>
- [ ] Repeated searches for same player use cached data (no redundant API calls)
- [ ] Cache persists across browser sessions (survives page reload)
- [ ] Data older than 15 minutes triggers background revalidation
- [ ] "Updated X min ago" timestamp displays correctly
- [ ] Manual refresh button forces fresh data fetch
- [ ] LRU eviction prevents localStorage overflow (max 10 entries)
- [ ] QuotaExceededError handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance/04-01-SUMMARY.md` with:
- Cache implementation details
- Performance measurements (before/after API call reduction)
- Any deviations from plan
- Next steps
</output>
