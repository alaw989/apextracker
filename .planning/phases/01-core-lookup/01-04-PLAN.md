---
phase: 01-core-lookup
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/stores/player.js
  - src/utils/api.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Player store can fetch data from Tracker.gg API via proxy"
    - "API response is transformed into app-friendly format"
    - "Errors are caught and stored in error state"
    - "Loading state is set during fetch"
    - "Transformed data includes name, avatar, rankIcon, stats array, legends array"
  artifacts:
    - path: "src/utils/api.js"
      provides: "API fetch utilities"
      exports: ["fetchPlayerStats"]
    - path: "src/stores/player.js"
      provides: "Player data store with API integration"
      exports: ["usePlayerStore"]
      contains: "fetchPlayer, transformApiData"
  key_links:
    - from: "src/stores/player.js"
      to: "src/utils/api.js"
      via: "import fetchPlayerStats"
      pattern: "fetchPlayerStats"
    - from: "src/stores/player.js"
      to: "src/utils/constants.js"
      via: "import API_CONFIG"
      pattern: "API_CONFIG"
---

<objective>
Implement API integration with Tracker.gg to fetch player stats via Heroku proxy.

Purpose: Connect the app to live data. The player store needs to fetch from Tracker.gg API v2 through the Heroku proxy (CORS workaround). Raw API responses must be transformed into a clean format for components to consume.

Output: Working API integration in player store with data transformation and error handling.
</objective>

<execution_context>
@/home/deck/.claude/get-shit-done/workflows/execute-plan.md
@/home/deck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-lookup/01-CONTEXT.md
@.planning/phases/01-core-lookup/01-RESEARCH.md
@src/App.js
@src/utils/constants.js
</context>

<tasks>

<task type="auto">
  <name>Create API fetch utility</name>
  <files>src/utils/api.js</files>
  <action>
    Create src/utils/api.js with API fetch logic:

    1. Import API_CONFIG from '@/utils/constants'

    2. Create fetchPlayerStats(username, platform) function:
       - Validates inputs (username not empty, platform valid)
       - Constructs URL: ${PROXY_URL}${BASE_URL}/${platform}/${username}
       - Sets headers: { 'TRN-Api-Key': API_KEY }
       - Uses fetch API to make GET request
       - Returns parsed JSON response
       - Throws error with descriptive message for:
         * 404: player not found
         * 429: rate limit exceeded
         * Network errors
         * Invalid response format

    3. Error handling:
       - Check response.ok before parsing
       - Use ERROR_MESSAGES from constants
       - Include status code in error for debugging

    4. Export as named export: fetchPlayerStats

    Reference existing fetch logic from src/App.js lines 55-131.
    Update to use API v2 slugs (origin, xbl, psn) not numeric codes.

    Example structure:
    ```javascript
    export async function fetchPlayerStats(username, platform) {
      const url = `${API_CONFIG.PROXY_URL}${API_CONFIG.BASE_URL}/${platform}/${username}`

      const response = await fetch(url, {
        headers: { 'TRN-Api-Key': API_CONFIG.API_KEY }
      })

      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(ERROR_MESSAGES.PLAYER_NOT_FOUND)
        }
        if (response.status === 429) {
          throw new Error(ERROR_MESSAGES.RATE_LIMIT)
        }
        throw new Error(ERROR_MESSAGES.NETWORK_ERROR)
      }

      return response.json()
    }
    ```
  </action>
  <verify>
    1. Create temporary test in browser console or in App.vue
    2. Test with known valid player: fetchPlayerStats('Respawn', 'origin')
    3. Test with invalid player: fetchPlayerStats('InvalidPlayerName123456789', 'origin')
    4. Verify 404 throws correct error
    5. Verify response has expected structure (data, segments, etc.)
  </verify>
  <done>
    fetchPlayerStats successfully fetches from Tracker.gg API via proxy, throws appropriate errors
  </done>
</task>

<task type="auto">
  <name>Implement data transformation in player store</name>
  <files>src/stores/player.js</files>
  <action>
    Update src/stores/player.js with complete implementation:

    1. Add transformApiData(apiResponse) function:
       - Extract segments from apiResponse.data.segments
       - Transform overview stats (segments[0].stats):
         * Loop through stats, filter for objects with displayName
         * Create array: { subtitle, stat } using displayValue or value
       - Filter and sort legends:
         * Filter: type !== 'overview' AND has kills stat
         * Sort by kills descending (b.kills.value - a.kills.value)
         * Take top 2 legends
         * Map to: { name, imageUrl, kills }
       - Extract player info:
         * name: platformInfo.platformUserHandle
         * avatar: platformInfo.avatarUrl
         * rankIcon: segments[0].stats.rankScore.metadata.iconUrl
       - Return transformed object

    2. Implement searchPlayer(username, platform) action:
       - Set loading=true, error=null
       - Try: call fetchPlayerStats, then transformApiData
       - Store result in data ref
       - Catch: set error ref with error message, set data=null
       - Finally: set loading=false
       - Return { success: boolean, error?: string }

    3. Update searchLoading state in sync with loading during search

    Reference existing transform logic from src/App.js lines 64-125.
    Follow pattern from RESEARCH.md "Pinia Store with Data Transformation" example.

    Transformed data structure:
    ```javascript
    {
      name: string,
      avatar: string,
      rankIcon: string,
      stats: Array<{ subtitle: string, stat: string }>,
      legends: Array<{ name: string, imageUrl: string, kills: string }>
    }
    ```
  </action>
  <verify>
    1. In browser console, get player store instance
    2. Call searchPlayer('Respawn', 'origin')
    3. Verify:
       - loading becomes true then false
       - data contains transformed player info
       - data.stats is array of overview stats
       - data.legends has 2 entries sorted by kills
       - error is null on success
    4. Test error case: invalid username
    5. Verify error message is set, data is null
  </verify>
  <done>
    searchPlayer fetches and transforms data correctly, error handling works
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
- [ ] fetchPlayerStats in api.js makes successful API calls
- [ ] Player store's searchPlayer action works end-to-end
- [ ] Transformed data has correct structure (name, avatar, rankIcon, stats, legends)
- [ ] Loading state toggles during fetch
- [ ] Errors are caught and stored for invalid players
- [ ] Legends are sorted by kills (descending) and limited to top 2
</verification>

<success_criteria>
1. fetchPlayerStats successfully calls Tracker.gg API via Heroku proxy
2. Player store's searchPlayer returns transformed data with all required fields
3. Invalid player search sets error state appropriately
4. Loading state is managed correctly during API calls
5. Top 2 legends by kills are extracted and sorted correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-lookup/01-04-SUMMARY.md`
</output>
